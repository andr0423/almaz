Тестовое задание
================

Тестовое задание
Есть многострочный текстовый файл
 с числами, записанными через пробел.
Его размер превышает размер имеющейся памяти.
Необходимо :
- сложить все числа,
- вычесть (из первого числа все остальные),
- выполнить операцию XOR.
Для работы с числами можно использовать не более трех потоков.
Необходимо с максимальной скоростью обработать файл. 
Результатом обработки являются три числа.
Для решения задачи необходимо использовать Qt или STL. 
Исходный код должен собираться под Linux.

Анализ
======
Многострочный текстовой файл
  Значит в нём числа разделены пробелам и переносами строк
  пример обработки был где-то в лабах курса avalon.ru

С числами, записанными через пробел
  С какими числами не сказано, вероятно int

Его размер превышает размер имеющейсы памяти
  Считать файл целиком в память нельзя.
  Читать нужно либо по одному числу и сразу обрабатывать.
  Либо считывать в буфер пачками (по 10-100-1000)
  Считывать вероятно в отдельном потоке.

Допущения: 
  все числа целые со знаком
  для упрощения пусть signed char, 1 байт, -128...127
  сумма и разность не выйдет за границы max-min int 
  данные в файле корректные
  файл не пустой
  операция чтения из файла медленная - оказалось НЕТ, самая быстрая 


План реализации
===============

Первое число нужно запомнить в переменной

ЛИБО
  Во ВТОРОМ ПОТОКЕ нужно складывать числа
  А в ТРЕТЬЕМ ПОТОКЕ делать XOR
ЛИБО
   Во втором потоке делать SUM и XOR, но потоков запустить два

Cкладывать и XOR начиная с первого числа, 
Для второго ответа, разность, нужно
  из удвоенного первого числа вычесть сумму из первого ответа.

Читать будет первый поток. 
Второй поток будет суммировать и делать XOR.
Подойдёт шаблок Producer-Consumer
Поэтому суммирование и XOR попробовать в одном потоке.
Читающий поток будет отправлять данные в queue.
Арифметический поток будет читать из queue.
Длину очереди попробую контролировать от бесконтрольного роста.
Для защиты от роста queue в первом и для ожидания поступления данных во втором потоке использую condition_variables.

Для генерации файла с тестовыми данными и подсчёта суммы/xor напишу скрипт на Python

Для удобства сборки/запуска набросаю Makefile


Промежуточный результат 1
=========================

Первый и второй коммиты в dev
https://gitflic.ru/project/andr0423/test-almaz?branch=dev
https://gitflic.ru/project/andr0423/test-almaz/commit/dac4bb7dd4de6e0b12d159d509a7206b9122da62

https://github.com/andr0423/test-almaz/tree/dev
https://github.com/andr0423/test-almaz/commit/dac4bb7dd4de6e0b12d159d509a7206b9122da62

Для изучения и отладки многопоточности 
использовал трейс вывод в std::cerr - я больше так не буду.

Собирается под macos и linux:
1) Apple clang version 14.0.3 (clang-1403.0.22.14.1)
   Target: x86_64-apple-darwin22.6.0
   Thread model: posix
2) g++ 7.5.0, openSUSE Leap 15.2, x86_64,  5.3.18-lp152.63-default
3) g++ 7.5.0, openSUSE Leap 15.2, ppc64le, 5.15.44-tu310.38-default

Скорость:  
+------------------+----+---------+-----------+------------+
| Файл 1М          | th | mac x86 | vm x86_64 | vm ppc64le | 
+------------------+----+---------+-----------+------------+
| stderr>file      |  1 |     72s |       80s |        72s |
+------------------+----+---------+-----------+------------+
| stderr>file      |  2 |    132s |      111s |        87s |
+------------------+----+---------+-----------+------------+
| stderr>/dev/null |  1 |     24s |       40s |        19s |
+------------------+----+---------+-----------+------------+
| stderr>/dev/null |  2 |     44s |       42s |        31s |
+------------------+----+---------+-----------+------------+

Проблемы:
Быстрее всего оказывается работает читающий поток. 
Думал, что потеря времени на локах. 
Нет - оказалось, что потери на std::cerr в потокозащищенных блоках.

Можно попробовать:
  - +выкинуть трейсовые операции записи cout/cerr

  - см выше + суммирование проводить внутри потока, вернуть результат
    и окончательный результат суммировать/xor из результатов 2-х потоков
    это снизит оверхед доступа к глобальным переменным суммы и xor

  - при росте очереди вычитывать по несколько значений за раз
  - использовать потокобезопасные коллекции (очередь)?

  - если в разные потоки SUM и XOR, то им нужно две разные очереди?

  - либо попробовать разделить файл на два/три диапазона, уточнив разделение по ' ' и '\n'
    открыть два/три файловых стрима для каждого потока свой,
    и читать/суммировать/XOR ввнутри каждого потока
    не пересекаясь с другими потоками по блокировакам

Промежуточный результат 2
=========================

Чудовищный оверхед от трейсов std::cout/std::cerr в потокобезопасных блоках!!!
Я как бы знал, что операции "дорогие", но чтобы в 20 раз и более.

  g++     -v -Wall -pthread -lpthread -std=c++11 -o mmt_c5.g++  mmt_c5.cpp
  clang++ -v -Wall -pthread -lpthread -std=c++11 -fdiagnostics-color=always -g -o mmt_c5.clang++  mmt_c5.cpp

+-----------------------+------------------+------------------+
|                       |     mac os       |   VM gcc 7.5.0   |
+------------------+----+--------+---------+--------+---------+
| Файл 1М          | th |    g++ | clang++ | x86_64 | ppc64le | 
+------------------+----+--------+---------+--------+---------+
| NO cerr/cout     |  2 | 0.605s |  0.585s | 0.824s |  0.812s |
+------------------+----+--------+---------+--------+---------+



