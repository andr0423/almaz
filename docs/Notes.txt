Тестовое задание
================

Тестовое задание
Есть многострочный текстовый файл
 с числами, записанными через пробел.
Его размер превышает размер имеющейся памяти.
Необходимо :
- сложить все числа,
- вычесть (из первого числа все остальные),
- выполнить операцию XOR.
Для работы с числами можно использовать не более трех потоков.
Необходимо с максимальной скоростью обработать файл. 
Результатом обработки являются три числа.
Для решения задачи необходимо использовать Qt или STL. 
Исходный код должен собираться под Linux.

Анализ
======
Многострочный текстовой файл
  Значит в нём числа разделены пробелам и переносами строк
  пример обработки был где-то в лабах курса avalon.ru

С числами, записанными через пробел
  С какими числами не сказано, вероятно int

Его размер превышает размер имеющейсы памяти
  Считать файл целиком в память нельзя.
  Читать нужно либо по одному числу и сразу обрабатывать.
  Либо считывать в буфер пачками (по 10-100-1000)
  Считывать вероятно в отдельном потоке.

Допущения: 
  все числа целые со знаком
  для упрощения пусть signed char, 1 байт, -128...127
  сумма и разность не выйдет за границы max-min int 
  данные в файле корректные
  файл не пустой
  операция чтения из файла медленная - ()
  с++11

  UPD1: операция чтения из файла очень быстрая
  UPD2: в оригинальном тестовом файле числа uint, мах 4293314638


План реализации
===============

Первое число нужно запомнить в переменной

ЛИБО
  Во ВТОРОМ ПОТОКЕ нужно складывать числа
  А в ТРЕТЬЕМ ПОТОКЕ делать XOR
ЛИБО
   В другом потоке делать SUM и XOR, но потоков запустить два
ЛИБО
   Разделить файл на три диарпазона, уточнив границы ' ' по '\n'
   И в потоке открыть стрим к части файла, читать из потока, SUM, XOR
   Таких потоков запустить несколько (3)

Cкладывать и XOR начиная с первого числа, 
Для второго ответа, разность, нужно
  из удвоенного первого числа вычесть сумму из первого ответа.

Читать будет первый поток. 
Второй поток будет суммировать и делать XOR.
Подойдёт шаблок Producer-Consumer
Поэтому суммирование и XOR попробовать в одном потоке.
Читающий поток будет отправлять данные в queue.
Арифметический поток будет читать из queue.
Длину очереди попробую контролировать от бесконтрольного роста.
Для защиты от роста queue в первом и для ожидания поступления данных во втором потоке использую condition_variables.

Для генерации файла с тестовыми данными и подсчёта суммы/xor напишу скрипт на Python

Для удобства сборки/запуска набросаю Makefile


Промежуточный результат 1
=========================

Первый и второй коммиты в dev
https://gitflic.ru/project/andr0423/test-almaz?branch=dev
https://gitflic.ru/project/andr0423/test-almaz/commit/dac4bb7dd4de6e0b12d159d509a7206b9122da62

https://github.com/andr0423/test-almaz/tree/dev
https://github.com/andr0423/test-almaz/commit/dac4bb7dd4de6e0b12d159d509a7206b9122da62

Для изучения и отладки многопоточности 
использовал трейс вывод в std::cerr - я больше так не буду.

Собирается под macos и linux:
1) Apple clang version 14.0.3 (clang-1403.0.22.14.1)
   Target: x86_64-apple-darwin22.6.0
   Thread model: posix
2) g++ 7.5.0, openSUSE Leap 15.2, x86_64,  5.3.18-lp152.63-default
3) g++ 7.5.0, openSUSE Leap 15.2, ppc64le, 5.15.44-tu310.38-default

Скорость:  
+------------------+----+---------+-----------+------------+
| Файл 1М          | th | mac x86 | vm x86_64 | vm ppc64le | 
+------------------+----+---------+-----------+------------+
| stderr>file      |  1 |     72s |       80s |        72s |
+------------------+----+---------+-----------+------------+
| stderr>/dev/null |  1 |     24s |       40s |        19s |
+------------------+----+---------+-----------+------------+
| stderr>file      |  2 |    132s |      111s |        87s |
+------------------+----+---------+-----------+------------+
| stderr>/dev/null |  2 |     44s |       42s |        31s |
+------------------+----+---------+-----------+------------+

Проблемы:
Быстрее всего оказывается работает читающий поток. 
Думал, что потеря времени на локах. 
Нет - оказалось, что потери на std::cerr в потокозащищенных блоках.

Сделал:
  - [v] очистил код от операций вывода cout/cerr

  - [v] см выше + суммирование проводить внутри потока, вернуть результат
        и окончательный результат суммировать/xor из результатов 2-х потоков
        это снизит оверхед доступа к глобальным переменным


Промежуточный результат 2
=========================

Чудовищный оверхед от трейсов std::cout/std::cerr в потокобезопасных блоках!!!
Я как бы знал, что операции "дорогие", но чтобы в 20 раз и более.

  g++     -v -Wall -pthread -lpthread -std=c++11 -o mmt_c5.g++  mmt_c5.cpp
  clang++ -v -Wall -pthread -lpthread -std=c++11 -fdiagnostics-color=always -g -o mmt_c5.clang++  mmt_c5.cpp

+-----------------------+-------------------+-------------------+
| Файл 1М               |      mac os       |    VM gcc 7.5.0   |
+------------------+----+---------+---------+---------+---------+
|                  | th |     g++ | clang++ |  x86_64 | ppc64le | 
+------------------+----+---------+---------+---------+---------+
| NO cerr/cout     |  2 |  0.605s |  0.585s |  0.824s |  0.812s |
+------------------+----+---------+---------+---------+---------+
| count inside thr |  2 |  0.620s |  0.582s |  0.619s |  0.661s |
+------------------+----+---------+---------+---------+---------+
| count inside thr |  1 |  0.237s |  0.236s |         |         |
+------------------+----+---------+---------+---------+---------+


+-----------------------+--------------------+-------------------+
| Файл 100M (104857600) |       mac os       |    VM gcc 7.5.0   |
+------------------+----+---------+----------+---------+---------+
|                  | th |     g++ |  clang++ |  x86_64 | ppc64le | 
+------------------+----+---------+----------+---------+---------+
| count inside thr |  2 | 58.711s | 60.750s  | 52.039s | 67.213s |
+------------------+----+---------+----------+---------+---------+
| count inside thr |  1 | 23.834s | 23.942s  |         |         |
+------------------+----+---------+----------+---------+---------+

Потоки блокируются. Неудачно. Один поток работает быстрее чем два.


Промежуточный результат 3
=========================

Сделал две раздельные очереди, две condition_variable и два мьютекса.
По набору на каждый арифметический поток.
Читающий поток поочерёдно захватывает то один, то другой мьютексы, 
отправляет данные поочерёдно в разные очереди 
и посылает уведомления в разные кондишн вариаблес.

Читающий поток отправляет данные в очереди пачками (btc) по несколько (10)

+-----------------------------+------------------+-------------------+
| Файл 100M (104857600)       |     mac os       |    VM gcc 7.5.0   |
+------------------+----+-----+-------+----------+---------+---------+
|                  | th |  bt |   g++ |  clang++ |  x86_64 | ppc64le | 
+------------------+----+-----+-------+----------+---------+---------+
| two QUEUE, batch |  2 |   5 | 11.9s |    11.8s |   21.5s |   15.1s |
+------------------+----+-----+-------+----------+---------+---------+
| two QUEUE, batch |  2 |  10 | 11.8s |    11.5s |   22.2s |   14.4s |
+------------------+----+-----+-------+----------+---------+---------+
| two QUEUE, batch |  2 | 100 | 11.9s |    11.7s |   21.1s |   15.5s |
+------------------+----+-----+-------+----------+---------+---------+



Уточнение задачи
================

Прислали оригинальный файл с тестовыми данными numbers_light.txt

1) реализовать загрузку данных по имени, имя файла передавать как первый аргумент

2) данные в файле отличаются от предопалагаемых char со знаком

В файле 1300 числа, все положительные, 
максимальное значение 4293314638, 
что укладывается в uint, но не помещается в signed int

    cat numbers_light.txt | tr ' ' '\n' | grep -E '[0-9]' | \ 
        awk 'BEGIN{max=0;count=0}{if($1>max)max = $1;count=count+1}'`   
             `'END{print"count:",count,"\nmax:  ",max}' 
    count: 1300 
    max:   4293314638

Посчитаем вручную (awk-ом) сумму, разность и xor (awk умеет xor только с неотрицательными)

    cat numbers_light.txt | tr ' ' '\n' | grep -E '[0-9]' | awk 'BEGIN{first=0;sum=0;subt=0;xr=0;n="\n"}'`
    `'{if(first==0){first=$1;xr=xor(xr,$1)}else{sum=sum+$1;xr=xor(xr,$1)}}'`
    `'END{print "  sum :",first+sum,n," subt:",first-sum,n," xor :",xr,n}'
      sum : 2758646078950 
      subt: -2751738516022 
      xor : 240293890

Диапазон int: −2147483648 до 2147483647
Диапазон uint: 0 до 4 294 967 295
Диапазон long long: от −9 223 372 036 854 775 808 до 9 223 372 036 854 775 807

Для суммы можно использовать unsigned long long.
Для разности signed long long.
Для xor достаточно uint.
Но генератор тестовых данных создаёт числа со знаком.
Уточнений по диапазонам тестовых данных не было.
Поэтому для sum, subt, xor воспользуюсь signed long long
На современных 64-разрядных процессорах машинное слово 64 бита,
поэтому замедления операций сложения и xor не должно наблюдаться.

+ достаточно минимальных переделок, только типы данных поменять
- long long может обрабатываться дольше чем xor по char и sum по int


Промежуточный результат 4
=========================

MacOS
+------------+----+-----+---------+
| file size  | th |  bt | clang++ | 
+------------+----+-----+---------+
|         1M |  2 |   5 |   0.15s |
+------------+----+-----+---------+
|       100M |  2 |  10 |   11.6s |
+------------+----+-----+---------+
|      1024M |  2 | 100 |   121.1s|
+------------+----+-----+---------+

Результат с тестовым файлом "numbers_light.txt"

    make execute
    ./mmt_c5 numbers_light.txt 2>/dev/null
    Summary:     2758646078950
    Subtraction: -2751738516022
    XOR:         240293890, '0000000000000000000000000000000000001110010100101001100000000010'





Улучшить или попробовать: 
=========================
  - использовать concurrent_queue
  - в генераторе данных можно переделать класс на любую длинну 
  - реализовать классом
  - при росте очереди увеличивать batch_size вычисляющих потоков, уменьшать в читающем  
  - SUM и XOR в разных потоках, тоже с разными очередями (?)

  - попробовать другой подход,
    например разделить файл на два/три диапазона,
    уточнив диапазоны по ' ' и '\n' чтобы не разрезать по числу,
    открыть два/три файловых стрима, для каждого потока свой,
    внутри потока из своего диапазона файла читать/суммировать/XOR 
    не пересекаясь с другими потоками по блокировакам
    SUM - сложить первое число и результаты из потоков
    SUBT - разность, из первого числа вычесть результаты потоков
    XOR - между первым числом и результатами из потоков

  - либо в потоке читать из диска блоками в память по 1m, sum/xor

