Тестовое задание
================

Тестовое задание
Есть многострочный текстовый файл
 с числами, записанными через пробел.
Его размер превышает размер имеющейся памяти.
Необходимо :
- сложить все числа,
- вычесть (из первого числа все остальные),
- выполнить операцию XOR.
Для работы с числами можно использовать не более трех потоков.
Необходимо с максимальной скоростью обработать файл. 
Результатом обработки являются три числа.
Для решения задачи необходимо использовать Qt или STL. 
Исходный код должен собираться под Linux.

Анализ
======
Многострочный текстовой файл
  Значит в нём числа разделены пробелам и переносами строк
  пример обработки был где-то в лабах курса avalon.ru

С числами, записанными через пробел
  С какими числами не сказано, вероятно int

Его размер превышает размер имеющейсы памяти
  Считать файл целиком в память нельзя.
  Читать нужно либо по одному числу и сразу обрабатывать.
  Либо считывать в буфер пачками (по 10-100-1000)
  Считывать вероятно в отдельном потоке.

Допущения: 
  все числа целые со знаком
  для упрощения пусть signed char, 1 байт, -128...127
  сумма и разность не выйдет за границы max-min int 
  данные в файле корректные
  файл не пустой
  операция чтения из файла медленная - (оказалось НЕТ, очень быстрая)
  с++11


План реализации
===============

Первое число нужно запомнить в переменной

ЛИБО
  Во ВТОРОМ ПОТОКЕ нужно складывать числа
  А в ТРЕТЬЕМ ПОТОКЕ делать XOR
ЛИБО
   В другом потоке делать SUM и XOR, но потоков запустить два
ЛИБО
   Разделить файл на три диарпазона, уточнив границы ' ' по '\n'
   И в потоке открыть стрим к части файла, читать из потока, SUM, XOR
   Таких потоков запустить несколько (3)

Cкладывать и XOR начиная с первого числа, 
Для второго ответа, разность, нужно
  из удвоенного первого числа вычесть сумму из первого ответа.

Читать будет первый поток. 
Второй поток будет суммировать и делать XOR.
Подойдёт шаблок Producer-Consumer
Поэтому суммирование и XOR попробовать в одном потоке.
Читающий поток будет отправлять данные в queue.
Арифметический поток будет читать из queue.
Длину очереди попробую контролировать от бесконтрольного роста.
Для защиты от роста queue в первом и для ожидания поступления данных во втором потоке использую condition_variables.

Для генерации файла с тестовыми данными и подсчёта суммы/xor напишу скрипт на Python

Для удобства сборки/запуска набросаю Makefile


Промежуточный результат 1
=========================

Первый и второй коммиты в dev
https://gitflic.ru/project/andr0423/test-almaz?branch=dev
https://gitflic.ru/project/andr0423/test-almaz/commit/dac4bb7dd4de6e0b12d159d509a7206b9122da62

https://github.com/andr0423/test-almaz/tree/dev
https://github.com/andr0423/test-almaz/commit/dac4bb7dd4de6e0b12d159d509a7206b9122da62

Для изучения и отладки многопоточности 
использовал трейс вывод в std::cerr - я больше так не буду.

Собирается под macos и linux:
1) Apple clang version 14.0.3 (clang-1403.0.22.14.1)
   Target: x86_64-apple-darwin22.6.0
   Thread model: posix
2) g++ 7.5.0, openSUSE Leap 15.2, x86_64,  5.3.18-lp152.63-default
3) g++ 7.5.0, openSUSE Leap 15.2, ppc64le, 5.15.44-tu310.38-default

Скорость:  
+------------------+----+---------+-----------+------------+
| Файл 1М          | th | mac x86 | vm x86_64 | vm ppc64le | 
+------------------+----+---------+-----------+------------+
| stderr>file      |  1 |     72s |       80s |        72s |
+------------------+----+---------+-----------+------------+
| stderr>/dev/null |  1 |     24s |       40s |        19s |
+------------------+----+---------+-----------+------------+
| stderr>file      |  2 |    132s |      111s |        87s |
+------------------+----+---------+-----------+------------+
| stderr>/dev/null |  2 |     44s |       42s |        31s |
+------------------+----+---------+-----------+------------+

Проблемы:
Быстрее всего оказывается работает читающий поток. 
Думал, что потеря времени на локах. 
Нет - оказалось, что потери на std::cerr в потокозащищенных блоках.

Сделал:
  - [v] очистил код от операций вывода cout/cerr

  - [v] см выше + суммирование проводить внутри потока, вернуть результат
        и окончательный результат суммировать/xor из результатов 2-х потоков
        это снизит оверхед доступа к глобальным переменным


Промежуточный результат 2
=========================

Чудовищный оверхед от трейсов std::cout/std::cerr в потокобезопасных блоках!!!
Я как бы знал, что операции "дорогие", но чтобы в 20 раз и более.

  g++     -v -Wall -pthread -lpthread -std=c++11 -o mmt_c5.g++  mmt_c5.cpp
  clang++ -v -Wall -pthread -lpthread -std=c++11 -fdiagnostics-color=always -g -o mmt_c5.clang++  mmt_c5.cpp

+-----------------------+-------------------+-------------------+
| Файл 1М               |      mac os       |    VM gcc 7.5.0   |
+------------------+----+---------+---------+---------+---------+
|                  | th |     g++ | clang++ |  x86_64 | ppc64le | 
+------------------+----+---------+---------+---------+---------+
| NO cerr/cout     |  2 |  0.605s |  0.585s |  0.824s |  0.812s |
+------------------+----+---------+---------+---------+---------+
| count inside thr |  2 |  0.620s |  0.582s |  0.619s |  0.661s |
+------------------+----+---------+---------+---------+---------+
| count inside thr |  1 |  0.237s |  0.236s |         |         |
+------------------+----+---------+---------+---------+---------+


+-----------------------+--------------------+-------------------+
| Файл 100M (104857600) |       mac os       |    VM gcc 7.5.0   |
+------------------+----+---------+----------+---------+---------+
|                  | th |     g++ |  clang++ |  x86_64 | ppc64le | 
+------------------+----+---------+----------+---------+---------+
| count inside thr |  2 | 58.711s | 60.750s  | 52.039s | 67.213s |
+------------------+----+---------+----------+---------+---------+
| count inside thr |  1 | 23.834s | 23.942s  |         |         |
+------------------+----+---------+----------+---------+---------+

Потоки блокируются. Неудачно. Один поток работает быстрее чем два.


Промежуточный результат 3
=========================

Сделал две раздельные очереди, две condition_variable и два мьютекса.
По набору на каждый арифметический поток.
Читающий поток поочерёдно захватывает то один, то другой мьютексы, 
отправляет данные поочерёдно в разные очереди 
и посылает уведомления в разные кондишн вариаблес.

Читающий поток отправляет данные в очереди пачками (btc) по несколько (10)

+-----------------------------+------------------+-------------------+
| Файл 100M (104857600)       |     mac os       |    VM gcc 7.5.0   |
+------------------+----+-----+-------+----------+---------+---------+
|                  | th |  bt |   g++ |  clang++ |  x86_64 | ppc64le | 
+------------------+----+-----+-------+----------+---------+---------+
| two QUEUE, batch |  2 |   5 | 11.9s |    11.8s |   21.5s |   15.1s |
+------------------+----+-----+-------+----------+---------+---------+
| two QUEUE, batch |  2 |  10 | 11.8s |    11.5s |   22.2s |   14.4s |
+------------------+----+-----+-------+----------+---------+---------+
| two QUEUE, batch |  2 | 100 | 11.9s |    11.7s |   21.1s |   15.5s |
+------------------+----+-----+-------+----------+---------+---------+


Улучшить или попробовать: 
=========================
  - SUM и XOR в разных потоках, тоже с разными очередями
  - использовать concurrent_queue
  - реализовать классом

  - попробовать другой подход,
    например разделить файл на два/три диапазона,
    уточнив диапазоны по ' ' и '\n' чтобы не разрезать по числу,
    открыть два/три файловых стрима, для каждого потока свой,
    внутри потока из своего диапазона файла читать/суммировать/XOR 
    не пересекаясь с другими потоками по блокировакам
    SUM - сложить первое число и результаты из потоков
    SUBT - разность, из первого числа вычесть результаты потоков
    XOR - между первым числом и результатами из потоков

  - либо в потоке читать из диска блоками в память по 1m, sum/xor

